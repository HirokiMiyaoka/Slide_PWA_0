# PWAの概要とライフサイクルを知る

がりがり書いてる途中なので間違い・長文多し

* 類似技術との簡易比較
* PWAでできること
* ライフサイクル周り
* 文章削って整理

---

## PWAとは

Progressive Web Apps(PWA)とは、HTML5で動作するページをネイティブアプリっぽく実行することが可能になる技術です。

ブラウザでアクセスすれば普通のWebアプリとして使えますが、インストールすることでネイティブアプリっぽく実行することも可能です。

有名どころではTwitter（モバイル版）やInstagramなどもPWA対応をしています。

+++

### 流行るの？

思ったより早く浸透しているので、結構流行るし当たり前の技術になっていく可能性が。

* Chromeウェブストアから「Chrome Apps」のセクション削除--PWAに移行へ
    * https://japan.cnet.com/article/35111628/
* Microsoft、年内に「Progressive Web Apps」（PWA）をアプリストアに追加へ
    * http://www.itmedia.co.jp/news/articles/1802/08/news067.html
* iOSのSafariでPWAがいよいよ動くようになった、iOS 11.3ベータ版がService Workerを本格的にサポート開始
    * https://www.suzukikenichi.com/blog/pwa-finally-begins-working-in-ios-safari/

+++

### PWA以前の様々な取り組み

PWA以前にも実はWebアプリの「ネイティブアプリ化」技術があった。

* Chromeのアプリケーション化
    * デスクトップにそのWebページを一発で開くショートカットを作り、起動時にはURLバーの排除など、よりアプリっぽく動作する
    * 個人的にはPWAの前身と思ってる。かなり昔からChromeに搭載されている機能
* アクティブデスクトップ/デスクトップガジェット・Windowsサイドバー
    * Windowsに搭載されていたWebアプリをデスクトップに設置する技術
      * 前者はWin98から正式搭載されていたらしいがVistaで廃止。使ったことない
      * Vistaではガジェットが搭載され（結構気に入っていたのに）7では廃止

+++

* Electronとか
    * Chrome+Node.jsを混ぜた各OSで動くアプリに、Webアプリを混ぜてそれっぽく実行する類のやつ
    * SlackとかVisualStudio Code等採用事例も多いが、ファイル容量が大きい、Webアプリ以外の実装部分が大きくなりがち
      * もちろん設計次第ではあるが
    * それ以外は概ねいい感じだと思っている

+++

### PWA以前の類似技術はぱっとしない

他にもいろいろとあるはずだが、これらはあまり使われなかったり廃止されたりとあんまりぱっとしないで忘れ去られるのが多いです。

* Webアプリが可能なことが貧弱すぎ、ネイティブアプリとして使うには力不足過ぎた
* 上を補うために独自APIを提供しても、独自仕様なので他で使えない＝開発コストが大きくなる

Electron系は技術系ではよく使われているのが、新規Webサービスでお手軽に……というより、技術に余力のある企業しか採用してない気が。

PWAはこれらをうまく解決しようとしている。

---

## PWAの特徴

PWAは主に以下の構造で動いています。

* Webアプリ部分
    * 通常のHTML5による実装
    * PWA専用のAPIはそんなに多いわけではなく、登録や通信程度
* それ以外
    * ブラウザの制御とかPush通知の処理とかを行う、少し特殊なJS実装
    * WebアプリとPWAの主だった差分部分はここ

+++

### PWAでできること

* ブラウザの制御
    * 通信やページ立ち上げなど一部ではあるがWebページの領域を超えたブラウザの制御が可能。
* 停止時の活動
    * Webページが開いていなくても、Push通知などを受け取った際にそのアプリに応じた処理が可能。
* デバイスへのインストール
    * スマートフォンのアプリインストールをより簡単にしたようなもの。
    * ページのダウンロード+α程度なのでそんなに時間もかからない。
    * 基本的にOSに依存しているので、場合によってはPWAは対応しているがインストールは対応してないとかいう状況もありうる。

+++

### PWAのメリット

* アプリインストールの煩わしさが軽減
    * PWAはブラウザで動作するので使うだけならインストール不要
    * 多用するならインストールできるし、軽量、自動アップデート
* ネイティブアプリ開発しなくてもそれっぽくできる
    * PWAをOSから開くとURLバーが消せたりもでき、ブラウザっぽさを感じさせないことも可能
    * 新規Webサービスは、初めからPWA対応しておけば疑似アプリとして利用可能
        * アプリは審査も必要でコストが高い
* Single Page Application(SPA)との相性が非常に良い

+++

### デメリット

* ネイティブよりパフォーマンスは劣る
    * 結局ブラウザの上で動くものなので、パフォーマンスはネイティブに劣る。
* OS/ブラウザの対応が必要
    * 単に動作するだけならブラウザ対応だけでOK。
    * ただし、アプリインストールなどはほぼOSに依存するため、OSの対応なしでは完全な状態で利用できない
* SPA以外との相性が悪い
    * ページ遷移がたくさん発生するCGIみたいな形式でもできなくはないが、オフライン対応などで少々辛い
    * オフライン時の動作を使用不可ページを表示するだけ、というようにばっさり切るならまだいける

+++

### 考慮するOS/ブラウザ

OSの協力も必要なことを考えると、注視しないといけないのが、以下OS/ブラウザです。

* Android/Chrome
* Mac/iOS/Safari
* Windows/Edge

Firefox等もいろいろ対応していますが、主に上については情報を積極的に集めた方が良いです。

+++

### PWAの動作条件(ブラウザ側)

デメリットにも書きましたが、OS/ブラウザの対応は必須なので、ブラウザで何が必要かを列挙しておきます。

* Web App Manifest
    * https://caniuse.com/#search=Web%20App%20Manifest
    * デバイスへのインストールに必要。
    * iOS Safari用にアイコンとか用意したらWebページをホームに追加した時反映されたと思うが、あれをひとまとめにして分離したもの
* ServiceWorker(SW)
    * https://caniuse.com/#search=Service%20Workers
    * PWAの主機能を担う部分。今回の実装のメイン。

OS標準のブラウザがこれらをサポートしていれば、PWAに対応していると言えます。

+++

### PWAの動作条件(アプリ側)

PWAは強力故に不正な攻撃をされると非常に危険です。
そのため以下の動作条件がアプリに課せられます。

* HTTPS通信もしくはローカルホスト(localhostや自分のIPアドレスなら可)

手元での開発にもWebサーバーが必要なことと、社内での開発環境でもHTTPSが必要です。

---

## 初めてのPWA

ここからは最低限のPWAの実装と、重要なライフサイクル周りの挙動をサンプルを交えながら実践していきます。

開発環境は以下とします。

* Chrome(シークレットウィンドウ)
    * 開発者モード実行時に壊れたりしたときリセットしやすい。
    * 最初からやりたいときにシークレットウィンドウを閉じるだけで良い。
* Webサーバー
    * 何でもいいのでhttpで接続できる状態に。
        * GitHub Pagesも独自ドメインを使わなければHTTPS対応しているので、テストならそれでも可。
    * localhostや自分のIPアドレスならポート番号等は特に気にしなくても問題ない。

+++?code=docs/manifest.json&title=/manifest.json

とりあえずこれ以降触ることのないManifestから作っておきます。
これがPWAのサイトの設定で、インストールされたときにここの情報を参照し、アイコンや名前などを設定します。
同時に144x144の `/icon-144.png` も用意しておきます。

+++?code=docs/0_minimal/sw.js&title=/0_minimal/sw.js

最も簡単なSW（何もしない空ファイル）を作ります。
ファイルとして存在していることは重要なので、ファイルだけは作ってください。


+++?code=docs/0_minimal/index.html&title=/0_minimal/index.html

Webアプリをミニマルな状態で作ります。

Web App ManifestとSWを登録することしかしていません。

+++

### ServiceWorker登録関数の説明

```
function InitServiceWorker() {
    if ( !( 'serviceWorker' in navigator ) ) { return; }
    navigator.serviceWorker.register( '/sw.js', {scope: '/'} );
}
```
@[2](navigatorにserviceWorkerがない場合は登録作業をしない)
@[3](実際の登録作業で、scopeはSWの動作範囲)

+++

### 今回のコード

```
function InitServiceWorker() {
    if ( !( 'serviceWorker' in navigator ) ) { return; }
    navigator.serviceWorker.register( './sw.js', {scope: './'} );
}
```

SWは同じサイトであっても対象となるスコープ=パスが異なれば複数設置可能なので、今回はサンプルをいくつか用意する都合上、このようなコードとなります。

+++

## PWAの確認について

初めにも書いたように、基本はChromeのシークレットウィンドウで確認しましょう。

今回はどちらかというと最低限のPWAのサンプルなので、PWA対応のスマートフォンのブラウザで開いてみると良いです。

具体的には現段階ではAndroidのChrome最新版であれば、以下の条件を満たすとホームに追加通知が出ますが、条件は暫定です。

* 複数回同じPWA対応サイトにアクセスする
* 前回アクセス時から5分以上経過

ブラウザのメニューからホームに追加も可能です。

---

## SWのライフサイクルを知る

実際にやってみてPWAのライフサイクル周りの実装が一番しんどいのでそこを重点的にやります。

その前にSWで必要な知識をまとめます。

+++

### 基本的なライフサイクル

SWには状態が3つあります。

* インストール
    * SWのスクリプトをダウンロードしてブラウザにインストールする段階
    * クライアント側で `register` を実行することで始まる
* 待機
    * 現在稼働中のSWが制御しているブラウザ・アプリ(クライアント)がある場合に待機する段階
    * 具体的には無理矢理更新or全てのクライアントが終了した後
* アクティブ
    * 正常にインストールされ、対象のクライアントを制御している段階

+++

### ライフサイクルの例

* 初回アクセス時
    * インストール→（稼働中のSWがないので通過→）アクティブ
    * ページ読み込み後なので、アクティブになるまでタイムラグがあるのに注意！
* 次回アクセス時
    * SWが古くないならすでにアクティブなので、初めからSWの制御下
* 次回アクセス時更新あり
    * SWが古いのでインストールが走る→稼働しているSWがあるので待機→制御中のクライアントがすべて終了したらアクティブ
    * 古いSWが稼働しているが更新されないのに注意！
        * 公式では、この次にアクセスしたときには最新になってるだろう。みたいな感じで書いてある

1,3番目がある意味の鬼門です。

+++

### ServiceWorkerの仕組み

ServieceWorkerは以下のような特徴を持っています。

* ブラウザ外のJS環境で実行され、登録されたイベントを呼び出す形式
* 必ず1日以上古いスクリプトはキャッシュ無視をして最新版をダウンロード・インストール
* 複数の同じPWAサイトでも1つのSWが対応
    * 正確には、SW登録時に設定したドメインとscopeが同じ場合、1つのSWしか稼働しない

+++

### 実行環境

* DOM操作等のAPIがなく、ブラウザ側の情報にアクセスできない
  * 通信処理を書けば情報やり取りは可能
* `location` はServiceWorkerのある場所を基準にする
* 以下のように `self` オブジェクトに対してイベントを登録する

```
self.addEventListener( 'install', (event) => { /*インストール時の挙動*/ } );
```

+++

### 最小の動作するSW

```
self.addEventListener( 'install', ( event ) => {
	console.log( 'SW:', 'install' );
	console.log( location );
} );

self.addEventListener( 'activate', ( event ) => {
	console.log( 'SW:', 'activate' );
} );
```

+++

### ServiceWorkerのキャッシュの挙動

* 更新時、差分が無ければ特に何もしない
    * 更新チェック(キャッシュ無視ダウンロード)→差分チェック→更新処理
* 1日を超えて古い物は必ず更新チェックされる
    * 登録したスクリプトは基本キャッシュヘッダに従う（はず）
* ブラウザ/アプリ側(クライアント側)から強制更新を走らせることも可能
    * もちろん差分が無ければ更新などは発生しない。

特に何も考えなければ、1日以内ですべての環境が新しいスクリプトになるという認識です。（待機という意味では）

+++

### ServiceWorkerの制御範囲

例えば以下のようなケースがあります。

* ブラウザでPWA対応ページを開き、ServiceWorkerをインストール
* 同じPWA対応ページをアプリとしてインストールしてさらに実行

この場合、両方のサイトが同時に動くのですが、これらの制御を1つのServiceWorkerが行います。複数立ち上がったりはしません。
これに対して立ちふさがる問題が次です。

+++

### ServiceWorkerの制御の難しさ

* 通信やクライアント側立ち上げに対し、ServiceWorkerは複数の選択肢がありうる
    * クライアント側は逆に選択肢がないので特に問題なし。
* ServiceWorker更新時に、更新を反映できない
    * 他のサイトを制御しているServiceWorkerがあるのに、無理に更新したらクライアント側とWerviceWorker側での整合性が取れなくなる。
        * 特にクライアント側で問題になる可能性が高い
    * この更新反映待ちを無視して強制的に反映することも可能

ただし、これはPWAを最大限に使う=ServiceWorkerの機能をフルで使う+クライアント側が完全依存する場合に発生する壁なので、あくまでサポート側に徹する使い方の場合特に強制反映しても問題ないため、今回の実装では無視します。


---

## 犬を猫にするサンプル

ライフサイクルを確認すべく、以下のようなことをしてみます。

* 犬の画像を表示
* SWをインストール要請5秒後に犬の画像をもう一枚表示
    * この時間にはSWのインストールは終わっているだろうということで。
* SW側ではfetchイベントを登録し、犬の画像をリクエストされたら猫の画像のリクエストに差し替える

+++?code=docs/2_dog2cat/index.html&title=/2_dog2cat/index.html

HTMLではSWの登録と5s後に `dog.svg` を表示するコードが書かれています。

+++?code=docs/2_dog2cat/sw.js&title=/2_dog2cat/sw.js

+++

### fetchイベントの登録

```
self.addEventListener( 'fetch', ( event ) => {
	console.log( 'SW:', 'fetch', event.request.url );
	const url = new URL( event.request.url );

	if ( url.origin == location.origin && url.pathname == '/Slide_PWA_0/2_dog2cat/dog.svg' ) {
		event.respondWith( fetch( '/Slide_PWA_0/2_dog2cat/cat.svg' ).then( ( response ) => {
			return response;
		} ) );
	}
} );
```
@[5](犬の画像のリクエストを探す)
@[6](猫の画像のリクエストに書き換え、その結果を犬の画像のレスポンスとして返す)
@[9](何もしない場合は通常のリクエストがそのまま走る)

+++

### 挙動

このサンプルは以下のような挙動になります。

* 犬の画像(`dog.svg`)が表示される
* SWがインストールされるが、すぐには有効化されない。
* SWによるリクエストの差し替えが発生しないため、5s後に犬の画像(`dog.svg`)を表示すると、犬の画像を表示する
* リロードするとSW制御下に入るので、犬の画像(`dog.svg`)を表示すると、SWが猫の画像(`cat.svg`)のレスポンスを返し、猫の画像を表示する

このように、SWは登録してもすぐに有効化するような記述がないと、リロード後にしか効果を発揮しません。
これが通常の挙動です。

---

## すぐに有効化するサンプル

SWインストール後すぐに有効化します。

+++?code=docs/3_dog2cat_update/sw.js&title=/3_dog2cat_update/sw.js

+++

### 更新後すぐに適用

```
self.addEventListener( 'activate', ( event ) => {
	console.log( 'SW:', 'activate' );
	event.waitUntil( self.clients.claim() );
} );
```
@[3](これを入れるとSWの制御下に入る予定のページすべてで新しいSWを有効化します)

+++

### 挙動

先ほど一行加えただけですが、以下のようになります。

* 犬の画像(`dog.svg`)が表示される
* SWがインストールされ、このページはSW制御下にないのですぐに有効化される
* SWによるリクエストの差し替えが発生しないため、5s後に犬の画像(`dog.svg`)を表示すると、犬の画像を表示する
* リロードするとSW制御下に入るので、犬の画像(`dog.svg`)を表示すると、SWが猫の画像(`cat.svg`)のレスポンスを返し、猫の画像を表示する

---

### 強制更新は発生しない

これでSWの早期有効化が実現しますが、同じSW制御下の別クライアントがいる場合、そのクライアントがすべて閉じられない限り、有効化されません。
つまり以下のような挙動になります。

* 犬の画像(`dog.svg`)が表示される
* SWがインストールされるが、旧SWが稼働中のため、待機状態になる。
* 旧SWのまま動作する。

これも解決するためには、次のようにします。

+++?code=docs/4_dog2cat_omake/sw.js&title=/4_dog2cat_omake/sw.js

+++

### インストールしたら待機状態にしない

```
self.addEventListener( 'install', ( event ) => {
	console.log( 'SW:', 'install' );
	event.waitUntil( self.skipWaiting() );
} );
```
@[3](これによりインストール後待機状態にしないため、activateの時にすべてのクライアントのSWが更新されます)

---

## さらに複雑な例

もう少し複雑なこととして、リクエストの書き換えではなく、あらかじめ猫の画像をキャッシュしておき、それのレスポンスを返すこととします。
SW以外は同じ挙動とします。

* install時には猫の画像をあらかじめダウンロードしてキャッシュする
* activate時には古いキャッシュを探してすべて削除する
* fetch時には犬の画像の時に猫の画像のキャッシュを返す

+++?code=docs/5_dog2cat_cache/sw.js&title=/5_dog2cat_cache/sw.js

+++

```
const DOMAIN = 'sample_static-v';
const CACHE_VERSION = 1;
const CACHE_NAME = DOMAIN + CACHE_VERSION;
```

キャッシュ用の定数達です。
キャッシュのバージョンは固定文字列+バージョン番号で管理されますが、自分で作ったキャッシュを正確に消すために分けてあります。

+++

```
self.addEventListener( 'install', ( event ) => {
	console.log( 'SW:', 'install' );
	event.waitUntil( caches.open( CACHE_NAME ).then( ( cache ) => {
		cache.add('/Slide_PWA_0/5_dog2cat_cache/cat.svg');
	} ).then( () => {
		return self.skipWaiting();
	} ) );
} );
```
@[3](キャッシュを今のバージョンで開きます)
@[4](猫の画像をダウンロードしてキャッシュに追加します)
@[6](SWを待機状態にしません)

+++

```
self.addEventListener( 'activate', ( event ) => {
	console.log( 'SW:', 'activate' );
	event.waitUntil( caches.keys().then( ( keys ) => {
		return Promise.all(
			keys.filter( ( key ) => {
				return key.indexOf( DOMAIN ) === 0 && key !== CACHE_NAME;
			} ).map( ( key ) => {
				console.log( 'Delete cache:', key );
				return caches.delete( key );
			} )
		);
	} ).then( () => {
		return self.clients.claim();
	} ) );
} );
```
@[3](キャッシュのキーを列挙します)
@[6](バージョン番号前まで一致し、それ以降が異なるキーのみを抽出します)
@[9](古いキャッシュを削除します)
@[13](SWを有効化します)

+++

```
self.addEventListener( 'fetch', ( event ) => {
	console.log( 'SW:', 'fetch', event.request.url );
	const url = new URL( event.request.url );

	if ( url.origin == location.origin && url.pathname == '/Slide_PWA_0/5_dog2cat_cache/dog.svg' ) {
		event.respondWith( caches.match( '/Slide_PWA_0/5_dog2cat_cache/cat.svg' ) );
	}
} );
```
@[5](キャッシュから猫の画像を引っ張り、そのレスポンスを返します)

+++

### 挙動

* 犬の画像(`dog.svg`)が表示される
* SWがインストールされ、猫の画像をキャッシュする
* 犬の画像がリクエストされたとき、キャッシュにある猫の画像のレスポンスを返す。
* リロードするとSW制御下に入るので、犬の画像(`dog.svg`)を表示すると、SWが猫の画像(`cat.svg`)のキャッシュからレスポンスを返す
    * サーバーの猫の画像にはリクエストが飛ばない

+++

### キャッシュの利用方法

今回は猫の画像しかキャッシュしませんでしたが、以下のような使い方が可能です。

* 最低限動作可能なファイル群をキャッシュしておき、キャッシュに存在するリソースはすべてキャッシュから返す
    * いわゆるオフライン対応
* 存在しない画像をあらかじめキャッシュしてある仮画像に差し替える
    * クライアント側では404のエラーが出ない
* リクエストするたびに結果をキャッシュし、次回以降アクセスが発生しないようにする
    * SNSのアイコンをキャッシュしてリクエストを抑えるなど

---

## まとめ

* PWAは今までのWebアプリで不可能だった様々な動作を可能とする
* SWをインストールした直後は動作しなかったり、置き換えが発生しない
    * SWは1つのPWA対応サイトに対し複数設定できるが、同じscopeのSWは1つしか動作しないため、処理の不整合を防がなければならない
    * 不整合とかどうでもいいから新しいのを適用する方法もある
* 登録周りのライフサイクルは複雑なため、何も考えずSWが登録されている前提で動作させてはいけない
    * 登録～有効化以外はイベント発生時という分かりやすい単位で動くので、序盤の初期設定だけはきっちりすること
    * 条件を満たすために、例えば登録作業後必ずSWの更新をかけ、更新作業が発生したらリロードするという手もある

---

 【余裕があるならServiceWorker実例】

---

## ServiceWorkerでXXXXXXを作ってみた

+++

### fetchイベントによる通信の制御について

ServiceWorkerは通信の制御が可能です。この通信とは以下のような流れです。

```
[通常]
Client == fetch ====================> Browser ==> WebServer
       <=============================         <==

[fetchイベント監視時]
Client == fetch ==> ServiceWorker ==> Browser ==> WebServer
       <=============================         <==
```

fetchはJSの`fetch`や`<img>`のsrc指定など様々なHTTPリクエスト全てです。

+++

### ServiceWorkerでエラーなくエラー画像を返してみた

JSとブラウザの通信の間に挟まっているので、レスポンスがエラーの画像の時には、あらかじめ持っているエラー画像を200で返すことも可能

```
[画像がないとき]
Client == fetch ====================> Browser ==> WebServer
   404 <============================= 404     <== 404

[画像がないときにエラー画像を返す]
Client == fetch ==> ServiceWorker ==> Browser ==> WebServer
   200 <===========  エラーなので   <== 404     <== 404
                     エラー画像を
                     200で返す
```

+++

レスポンスの書き換えが可能なら、つまり、こういうことも可能。

```
[fetchイベント監視時]
Client == fetch ==> ServiceWorker ==> Browser ==> WebServer
       <===========               <==         <==
[fetchイベント監視時]
Client == fetch ==> ServiceWorker
       <=========== Responseを作って返す
```

+++

Webサーバーが作れるのでは？

+++

### ServiceWorkerでWeb/APIサーバーを作ってみた

仕様：

* 初回は絶対にWebサーバーからダウンロードが走るので、その時に必要ファイルをすべてキャッシュする
    * HTML、JS、最低限の画像
* 準備完了次第Webページをリロードする
    * それ以降は全ての通信がServieWorker管理下に置かれる
* Webページのリソースはキャッシュのデータを返す
* APIアクセスはServiceWorker側で処理をして返す

+++

+++

### 今回のサンプルの利用価値について

ぶっちゃけるとほぼ無意味。

ただ、開発時に仮APIをServiceWorkerで作ってWebアプリ側は通常のアクセスのように振る舞うとか、一人プレイはServiceWorkerが対応し、複数人の時のみサーバーが頑張る作りにすれば、Webアプリ側の実装をほぼ変えずに対応可能とか、そういう使い道はあるかも。

ついでに、Node.jsのExpressのServiceWorker版もお遊びで作られているらしいので、何か有効な使い方をする人が出てくるかも？
